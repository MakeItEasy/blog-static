%template ProgramLife
%toc

=== 指令一览 ===
<hr>
* mov: 传送指令
* add: 加法
* sub: 减法
* loop: 循环
* inc: 递增,+1
* dec: 递减,-1
* push: 入栈
* pop: 出栈
* and
* or
* div: 除法(除号前为被除数,除号后为除数)
* jmp: 无条件转移指令
* jcxz: 有条件转移指令（jmp when cx is zero）
* ret & retf: return转移指令
* call: 转移指令，调用子程序
* mul: 乘法指令，都是8位，用al乘，ax存放；都是16位，用ax乘，用dx存放结果高位，ax存放结果低位。
* adc: 带进位加法指令。
* sub: 带借位减法指令。
* cmp: 比较指令，功能相当于减法指令，只是不保存结果。只对标志寄存器产生影响。
* movsb
* movsw
* shl:逻辑左移指令
* shr:逻辑右移指令（要移动的位数，可以保存在cl中）最后移出的一位写入CF中，低位/高位补0
* sti：用于设置IF=1
* cti：用于设置IF=0

=== push ===
<hr>
* push ax 进行的操作
	# SP = SP-2, SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；
	# 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶

=== pop ===
<hr>
* pop ax 进行的操作
	# 将SS:SP指向的内存单元处的数据送入ax中
	# SP = SP+2, SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶；

=== loop ===
<hr>
* 格式：loop 标号 （(cx)=(cx)-1, 如果(cx)!=0,转移到标号处执行）
* 进行的操作
	# (cx)=(cx)-1
	# 如果(cx)!=0,(IP)=(IP)+8

=== and ===
<hr>
* 逻辑与命令，按位进行与运算<br />
通过该指令可以将操作对象的相应位设为0，其他位不变。<br />
例如：
{{{
  将al的第6位设为0
	and al, 10111111B
  }}}
  
=== or ===
<hr>
* 逻辑或命令，按位进行或运算<br />
通过该指令可以将操作对象的相应位设为1，其他位不变。<br />
例如：
{{{
  将al的第6位设为1
	or al, 01000000B
  }}}

=== div ===
<hr>
* 总结(Page157)
	# 除数: 8位和16位两种,在一个寄存器或内存单元中
	# 被除数: 默认放在AX或者DX和AX中,如果除数为8位,被除数则为16位,默认在AX中.<br />
		如果除数为16位,被除数则为32位,在DX和AX中存放,DX存放高16位,AX存放低16位.
	# 结果: 如果除数为8位,则AL存储除法操作的商,AH存余数.如果除数为16位,则AX存商,DX存余数.
* 列子及含义
	# div byte ptr ds:[0]
{{{
含义为:
	(al)=(ax)/((ds)*16+0)的商
	(ah)=(ax)/((ds)*16+0)的余数
  }}}
	# div word ptr es:[0]
{{{
含义为:
	(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商
	(dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数
  }}}

=== jmp ===
<hr>
* 格式
	# 段内短转移
{{{
  jmp short 标号（转到标号处执行指令）
  功能为：(IP) = (IP) + 8位位移
  }}}
	# 段内近转移
{{{
  jmp near ptr 标号（转到标号处执行指令）
  功能为：(IP) = (IP) + 16位位移
  }}}
	# 段间转移（远转移）
{{{
  jmp far ptr 标号
  功能为：
  	(CS) = 标号所在段的段地址
  	(IP) = 标号在段中的偏移地址
  }}}
* X位位移是编译器根据标号计算的。<br />
	计算方法为：X位位移=指令"标号"处的地址- _*jmp指令后*_ 的第一个字节的地址
* 转移地址在内存中的jmp指令
	# jmp word ptr 内存单元地址（段内转移）
	# jmp dword ptr 内存单元地址（段间转移）
		* （CS）=（内存单元地址+2）
		* （IP）=（内存单元地址）
=== jcxz ===
<hr>
* 格式： jcxz 标号（如果(cx)=0,转移到标号处执行）
* 相当于：
{{{
  if((cx) == 0) jmp short 标号
  }}}
  
=== ret && retf ===
<hr>
* ret相当于：pop IP
* retf相当于：
	# pop IP
	# pop CS

=== call ===
<hr>
* call进行两步操作：
	# 将当前的IP或CS和IP压入栈中
	# 转移
* call指令不能实现短转移
* call指令的格式
	# call 标号（将当前的IP压栈后，转到标号处执行指令）
	# call far ptr 标号：段间转移
	# call 16位寄存器
	# call word ptr 内存单元地址，相当于：
{{{
	push IP
	jmp word ptr 内存单元地址
  }}}
	# call dword ptr 内存单元地址，相当于：
{{{
	push CS
	push IP
	jmp dword ptr 内存单元地址
  }}}

=== adc ===
<hr>
* 指令格式：adc 操作对象1，操作对象2
* 功能：操作对象1 = 操作对象1 + 操作对象2 + CF
	比如指令adc ax,bx 实现的功能是：(ax)=(ax)+(bx)+CF
* 加法可以分两步来进行：
	# 低位相加；
	# 高位相加再加上低位相加产生的进位值。
* 这样提供adc指令的目的，就可以实现更大数据的加法运算。

=== sbb ===
<hr>
* 指令格式：sbb 操作对象1，操作对象2
* 功能：操作对象1 = 操作对象1 - 操作对象2 - CF
	比如指令sbb ax,bx 实现的功能是：(ax)=(ax)-(bx)-CF
* 减法可以分两步来进行：
	# 低位相减；
	# 高位相减再减去低位相减产生的借位值。
* 这样提供sbb指令的目的，就可以实现更大数据的减法运算。

=== cmp ===
<hr>
* 指令格式：cmp 操作对象1，操作对象2
* 功能：计算 操作对象1 - 操作对象2 但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。
	比如指令cmp ax,ax，做(ax)-(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位。<br />
	指令执行后：ZF=1, PF=1, SF=0, CF=0, OF=0

=== 条件转移指令小结 ===
<hr>

| 指令 | 含义         | 检测的相关标志位 | 备注      |
| je   | 等于则转移   | ZF=1             | equal     |
| jne  | 不等于则转移 | ZF=0             | not equal |
| jb   | 低于则转移   | CF=1             | below     |
| jnb  | 不低于则转移 | CF=0             | not below |
| ja   | 高于则转移   | CF=0且ZF=0       | above     |
| jna  | 不高于则转移 | CF=1或ZF=1       | not above |

=== movsb ===
<hr>
* 功能：执行movsb指令相当于进行下面几步
	# ((es)*16+(di))=((ds)*16+(si))
	# 如果DF=0则：(si)=(si)+1
				  (di)=(di)+1
	  如果DF=1则：(si)=(si)-1
				  (di)=(di)-1

=== movsw ===
<hr>
* movsw的功能是将ds:si指向的内存字单元中word送入es:di中，然后根据标志寄存器DF位的值，将si和di递增2或递减2
* movsb和movsw经常和rep配合使用
	# rep movsb相当于：
	{{{
		s:movsb
			loop s
	  }}}

=== pushf & popf===
<hr>
* 将标识寄存器的值压栈和出栈，为直接访问标志寄存器提供了一种方法。


